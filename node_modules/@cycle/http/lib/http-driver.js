"use strict";

var Rx = require("rx");
var superagent = require("superagent");

function optionsToSuperagent(_ref) {
  var url = _ref.url;
  var _ref$send = _ref.send;
  var send = _ref$send === undefined ? null : _ref$send;
  var _ref$accept = _ref.accept;
  var accept = _ref$accept === undefined ? null : _ref$accept;
  var _ref$query = _ref.query;
  var query = _ref$query === undefined ? null : _ref$query;
  var _ref$user = _ref.user;
  var user = _ref$user === undefined ? null : _ref$user;
  var _ref$password = _ref.password;
  var password = _ref$password === undefined ? null : _ref$password;
  var _ref$field = _ref.field;
  var field = _ref$field === undefined ? null : _ref$field;
  var _ref$attach = _ref.attach;
  var attach = _ref$attach === undefined ? null : _ref$attach;
  var _ref$withCredentials = _ref.withCredentials;
  var // if valid, should be an array
  withCredentials = _ref$withCredentials === undefined ? false : _ref$withCredentials;
  var _ref$headers = _ref.headers;
  var headers = _ref$headers === undefined ? {} : _ref$headers;
  var _ref$redirects = _ref.redirects;
  var redirects = _ref$redirects === undefined ? 5 : _ref$redirects;
  var _ref$type = _ref.type;
  var type = _ref$type === undefined ? "json" : _ref$type;
  var _ref$method = _ref.method;
  var method = _ref$method === undefined ? "get" : _ref$method;

  if (typeof url !== "string") {
    throw new Error("Please provide a `url` property in the request options.");
  }
  var lowerCaseMethod = method.toLowerCase();
  var sanitizedMethod = lowerCaseMethod === "delete" ? "del" : lowerCaseMethod;

  var request = superagent[sanitizedMethod](url);
  if (typeof request.redirects === "function") {
    request = request.redirects(redirects);
  }
  request = request.type(type);
  if (send !== null) {
    request = request.send(send);
  }
  if (accept !== null) {
    request = request.accept(accept);
  }
  if (query !== null) {
    request = request.query(query);
  }
  if (withCredentials) {
    request = request.withCredentials();
  }
  if (user !== null && password !== null) {
    request = request.auth(user, password);
  }
  for (var key in headers) {
    if (headers.hasOwnProperty(key)) {
      request = request.set(key, headers[key]);
    }
  }
  if (field !== null) {
    for (var key in field) {
      if (field.hasOwnProperty(key)) {
        request = request.field(key, field[key]);
      }
    }
  }
  if (attach !== null) {
    for (var i = attach.length - 1; i >= 0; i--) {
      var a = attach[i];
      request = request.attach(a.name, a.path, a.filename);
    }
  }
  return request;
}

function createResponse$(reqOptions) {
  return Rx.Observable.create(function (observer) {
    var request = optionsToSuperagent(reqOptions);

    try {
      if (reqOptions.progress) {
        request = request.on("progress", function (res) {
          res.request = reqOptions;
          observer.onNext(res);
        });
      }
      request.end(function (err, res) {
        if (err) {
          observer.onError(err);
        } else {
          res.request = reqOptions;
          observer.onNext(res);
          observer.onCompleted();
        }
      });
    } catch (err) {
      observer.onError(err);
    }

    return function onDispose() {
      request.abort();
    };
  });
}

function normalizeRequestOptions(reqOptions) {
  if (typeof reqOptions === "string") {
    return { url: reqOptions };
  } else if (typeof reqOptions === "object") {
    return reqOptions;
  } else {
    throw new Error("Observable of requests given to HTTP Driver must emit " + "either URL strings or objects with parameters.");
  }
}

function isolateSink(request$, scope) {
  return request$.map(function (req) {
    if (typeof req === "string") {
      return { url: req, _namespace: [scope] };
    }
    req._namespace = req._namespace || [];
    req._namespace.push(scope);
    return req;
  });
}

function isolateSource(response$$, scope) {
  var isolatedResponse$$ = response$$.filter(function (res$) {
    return Array.isArray(res$.request._namespace) && res$.request._namespace.indexOf(scope) !== -1;
  });
  isolatedResponse$$.isolateSource = isolateSource;
  isolatedResponse$$.isolateSink = isolateSink;
  return isolatedResponse$$;
}

function makeHTTPDriver() {
  var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? { eager: false } : arguments[0];

  var _ref2$eager = _ref2.eager;
  var eager = _ref2$eager === undefined ? false : _ref2$eager;

  return function httpDriver(request$) {
    var response$$ = request$.map(function (request) {
      var reqOptions = normalizeRequestOptions(request);
      var response$ = createResponse$(reqOptions);
      if (typeof reqOptions.eager === "boolean" ? reqOptions.eager : eager) {
        response$ = response$.replay(null, 1);
        response$.connect();
      }
      response$.request = reqOptions;
      return response$;
    }).replay(null, 1);
    response$$.connect();
    response$$.isolateSource = isolateSource;
    response$$.isolateSink = isolateSink;
    return response$$;
  };
}

module.exports = {
  optionsToSuperagent: optionsToSuperagent,
  createResponse$: createResponse$,

  makeHTTPDriver: makeHTTPDriver
};